## 用两个栈实现队列(简单题)

以为很简单，但是没做出来，依稀记得做过，有点菜

题目分析：两个栈实现队列，栈式先入后出，队列是先入先出

维护一个栈用来收集数据，遇到需要删除队列的，需要把 A 栈中的数据放入 B 栈中

如果 b 栈中为空 返回-1

```js
var CQueue = function () {
  this.stackA = [];
  this.stackB = [];
};

/**
 * @param {number} value
 * @return {void}
 */
CQueue.prototype.appendTail = function (value) {
  this.stackA.push(value);
};

/**
 * @return {number}
 */
CQueue.prototype.deleteHead = function () {
  if (this.stackB.length) {
    // 如果有数据直接删除最后一个数据
    return this.stackB.pop();
  } else {
    while (this.stackA.length) {
      // 数据为空 ，需要把A中数据放入 B中
      this.stackB.push(this.stackA.pop());
    }
    if (!this.stackB.length) {
      // B为空直接返回-1
      return -1;
    } else {
      // 不为空 删除B中最后一个数返回
      return this.stackB.pop();
    }
  }
};

/**
 * Your CQueue object will be instantiated and called as such:
 * var obj = new CQueue()
 * obj.appendTail(value)
 * var param_2 = obj.deleteHead()
 */
```

图片来源 leetcode

![](img/stack_01.gif)

次数（1）

## 删除最外层的括号(简单)

输入："(()())(())"
输出："()()()"

输入："()()(()())"
输出："()()"

```js
/**
 * @param {string} S
 * @return {string}
 */
var removeOuterParentheses = function (S) {
  let data = "",
    level = 0,
    i = 0;
  for (; i < S.length; i++) {
    if (S[i] === "(" && level++ > 0) {
      data += "(";
    }
    if (S[i] === ")" && level-- > 1) {
      data += ")";
    }
  }
  return data;
};
```

删除最外层的括号：计数法，遇到(就加 1 遇到)就减一

( ) ( )( ( )( ) )

0 第一个必然不符合要求 遍历之后变成 1
然后遇到)括号 减一变成 0 也不符合要求
同理：三四步一样

五 还是 0 遍历之后变成 1 不符合要求
六：还是( 遍历 后是 2 符合要求
七：) 减一 后是 1 也符合要求
八： ( 加一变成 2 符合要求
九：) 减一 变成 1 符合要求
十：)减一 变成 0 不符合要求

最后把所有符合要求的都拼接起来 就是最后符合要求的 括号

次数（1）

## 删除字符串中的所有相邻重复项 (简单题)

终于自己做出来一题了

输入："abbaca"
输出："ca"
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。

```js
/**
 * @param {string} S
 * @return {string}
 */
var removeDuplicates = function (S) {
  let data = [],
    i = 0;
  for (; i < S.length; i++) {
    if (!data.length) {
      data.push(S[i]);
    } else {
      if (data[data.length - 1] === S[i]) {
        data.splice(data.length - 1, 1);
      } else {
        data.push(S[i]);
      }
    }
  }
  return data.join("");
};
```

大致思路，每次循环都拿最新的数据 和栈中的最后一个进行比较 相同则把栈中最后一个 删除 否则入栈

次数（一次）

## 剑指 Offer 30. 包含 min 函数的栈 (简单题)

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min(); --> 返回 -3.
minStack.pop();
minStack.top(); --> 返回 0.
minStack.min(); --> 返回 -2.

```js
/**
 * initialize your data structure here.
 */
var MinStack = function () {
  this.stackA = []; // 维护一个最小栈
  this.stackB = []; // 正常栈
};

/**
 * @param {number} x
 * @return {void}
 */
MinStack.prototype.push = function (x) {
  this.stackB.push(x);
  if (!this.stackA.length) {
    this.stackA.push(x);
  } else {
    // 最终要的是 如果x 比 栈中最后一个元素小，那么x 可以进栈，如果x 比 栈中最后一个元素大，那么x不入栈，把栈中最后一个元素 再次入栈，保证元素个书以及最小栈结构
    if (x < this.stackA[this.stackA.length - 1]) {
      this.stackA.push(x);
    } else {
      this.stackA.push(this.stackA[this.stackA.length - 1]);
    }
  }
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function () {
  // 正常删除即可
  this.stackB.pop();
  this.stackA.pop();
};

/**
 * @return {number}
 */
MinStack.prototype.top = function () {
  return this.stackB[this.stackB.length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.min = function () {
  // 取最小栈中的最后一个就是最小值
  return this.stackA[this.stackA.length - 1];
};

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(x)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.min()
 */
```

比较简单，多做几次栈的题目，这种题目就很容易想到

次数（1 次）

## 剑指 Offer 59 - II. 队列的最大值

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数 max_value、push_back 和 pop_front 的均摊时间复杂度都是 O(1)。

若队列为空，pop_front 和 max_value  需要返回 -1

输入:
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]

```js
var MaxQueue = function () {
  this.quene = [];
  this.queneMax = [];
};

/**
 * @return {number}
 */
MaxQueue.prototype.max_value = function () {
  if (this.queneMax.length === 0) return -1;
  return this.queneMax[0];
};

/**
 * @param {number} value
 * @return {void}
 */
MaxQueue.prototype.push_back = function (value) {
  this.quene.push(value);

  while (
    this.queneMax.length &&
    this.queneMax[this.queneMax.length - 1] < value
  ) {
    this.queneMax.pop();
  }
  this.queneMax.push(value);
};

/**
 * @return {number}
 */
MaxQueue.prototype.pop_front = function () {
  if (this.quene.length === 0) return -1;
  const value = this.quene.shift();
  if (value === this.queneMax[0]) {
    this.queneMax.shift();
  }
  return value;
};

/**
 * Your MaxQueue object will be instantiated and called as such:
 * var obj = new MaxQueue()
 * var param_1 = obj.max_value()
 * obj.push_back(value)
 * var param_3 = obj.pop_front()
 */
```

做题思路，维护一个最大队列，如果进入队列的值大于当前队列的最后一个，那么队列中的值出队列，直到符合条件 进入队列

次数（1）

## 剑指 Offer 31. 栈的压入、弹出序列(中等)

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1

```js
/**
 * @param {number[]} pushed
 * @param {number[]} popped
 * @return {boolean}
 */
var validateStackSequences = function (pushed, popped) {
  let stack = [],
    i = 0,
    j = 0;
  for (; i < pushed.length; i++) {
    stack.push(pushed[i]);
    // 关键是while循环 一直出栈到条件不成立位置
    while (stack[stack.length - 1] === popped[j] && stack.length) {
      stack.pop();
      ++j;
    }
  }
  return stack.length === 0;
};
```

做题思路：创建一个辅助栈，循环入栈 pushed 每次入栈都检查 popped 是否和辅助栈栈顶元素一样，如果一样那么出栈，最后判断辅助栈是否为空，如果为空那么就是正确的，如果不为空那么就是错误的

[这个图解思路比较好理解](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/solution/mian-shi-ti-31-zhan-de-ya-ru-dan-chu-xu-lie-mo-n-2/)

次数（1）
