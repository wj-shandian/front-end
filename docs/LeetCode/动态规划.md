## 动态规划原理

- 基本思想：问题的最优解如果可以由子问题的最优解推导得到，则可以先求解子问题的最优解，在构造原问题的最优解；若子问题有较多的重复出现，则可以自底向上从最终子问题向原问题逐步求解。
- 使用条件：可分为多个相关子问题，子问题的解被重复使用
  - Optimal substructure（优化子结构）：
    - 一个问题的优化解包含了子问题的优化解
    - 缩小子问题集合，只需那些优化问题中包含的子问题，降低实现复杂性
    - 我们可以自下而上的
  - Subteties（重叠子问题）：在问题的求解过程中，很多子问题的解将被多次使用。
- 动态规划算法的设计步骤：
  - 分析优化解的结构
  - 递归地定义最优解的代价
  - 自底向上地计算优化解的代价保存之，并获取构造最优解的信息
  - 根据构造最优解的信息构造优化解
- 动态规划特点：
  - 把原始问题划分成一系列子问题；
  - 求解每个子问题仅一次，并将其结果保存在一个表中，以后用到时直接存取，不重复计算，节省计算时间
  - 自底向上地计算。
  - 整体问题最优解取决于子问题的最优解（状态转移方程）（将子问题称为状态，最终状态的求解归结为其他状态的求解）

<font color=red >
首先，动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。

既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。

动态规划这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！
</font>

## 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。

1.  1 阶 + 1 阶
2.  2 阶

经典的动态规划问题，类似斐波那契数列，虽然之前做过斐波那契数列，但是没有一下想到解法，（太菜）

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function (n) {
  let p = 0,
    q = 0,
    r = 1,
    i = 1;
  for (; i <= n; i++) {
    p = q;
    q = r;
    r = p + q;
  }
  return r;
};
```

![动态规划](img/07.gif)

每次爬一个楼梯或者两个楼梯，那么不论爬多少个楼梯最终都会分解成一个或者两个楼梯
就是一种取最值问题

次数（1）
