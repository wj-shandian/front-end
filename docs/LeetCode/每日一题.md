## 验证外星语词典

某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。

给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。

示例 1：

输入：words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
输出：true
解释：在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。

分析 ： 这题最难的是理解题意 ，开始看了几遍，没看懂题目意思，后面看了别人的解析才算理解

题目大意是：给一个 order 字母顺序 然后再给一个 words 的单词数组，两个两个单词比较，（然后两次单词比较再拆解成字母的比较）

比如 上面示例 1：

h -> l 比较
e -> e 比较
l -> e 比较
l -> t 比较
o -> c 比较
undefined -> o 比较
... 后面的忽略

根据给的 order 比较单词字母的顺序 如果 h -> l 比较 h 小 那么则是正确的 则继续下一个比较 如果相等 那么继续下一个比较 如果 l -> e 比较 l 比 e 大，那么直接终止 返回 false 当然 还有 undefined -> o 这种异常情况 这种默认是前者比后者小

题解

```TS
function isAlienSorted(words: string[], order: string): boolean {
      let data = new Map()
      for(let i=0;i<order?.length;i++){
          // 把order顺序存储下来
          data.set(order[i],i)
      }
      // 异常情况也存储
      data.set(undefined,-1)
      for(let i=0;i<words?.length - 1;i++){
          for(let j=0;j<Math.max(words[i]?.length,words[i+1]?.length);j++){
              if(words[i][j]===words[i+1][j]) continue // 如果相等则终止 跳出 继续下一个
              if(data.get(words[i][j])>data.get(words[i+1][j])) return false
              // 如果 data.get(words[i][j])<data.get(words[i+1][j]) 也终止跳出 继续下一个
              break
          }
      }
      return true
};
```

时间：2022-05-17

## 最少移动次数使数组元素相等 II

给你一个长度为 n 的整数数组 nums ，返回使所有数组元素相等需要的最少移动数。

在一步操作中，你可以使数组中的一个元素加 1 或者减 1 。

示例 1：

输入：nums = [1,2,3]
输出：2
解释：
只需要两步操作（每步操作指南使一个元素加 1 或减 1）：
[1,2,3] => [2,2,3] => [2,2,2]

分析：这题我的解法是通过中位数获取最优解，那为什么中位数是最优解呢，那么我们来分析一下

假设 我们给一个有序的数组 [a,b] b 比 a 大

第一种：
设定目标值 x 是在 a b 之间 ，
那么移动的次数 = x-a + b - x 得出 b-a

第二种：
设定目标值 x 是 大于 b 的
那么移动的次数 `= x-b + x - a =(x+b-b-b)+(x-a) = (b-a)+2*(x-b)` 这个步数一定是大于 b-a 的

第三种：
设定目标 x 是小于 a 的
那么移动的次数` = (b - x) + (a - x) = (b - a + a - x) + (a - x) = b - a + 2 * (a - x)`这个步数也是是大于 b-a 的

所以取中位数是步数最少的最优解

那么我们就可以开始排序数组 取中位数 遍历循环出 具体看下面解法

```ts
function minMoves2(nums: number[]): number {
  nums.sort((a, b) => a - b);
  let n = nums?.length;
  let mind = nums[Math.floor(n / 2)];
  let res = 0;
  for (let i = 0; i < n; i++) {
    res += Math.abs(nums[i] - mind);
  }
  return res;
}
```

时间：2022-05-19
