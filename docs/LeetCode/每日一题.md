## 验证外星语词典

某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。

给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。

示例 1：

输入：words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
输出：true
解释：在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。

分析 ： 这题最难的是理解题意 ，开始看了几遍，没看懂题目意思，后面看了别人的解析才算理解

题目大意是：给一个 order 字母顺序 然后再给一个 words 的单词数组，两个两个单词比较，（然后两次单词比较再拆解成字母的比较）

比如 上面示例 1：

h -> l 比较
e -> e 比较
l -> e 比较
l -> t 比较
o -> c 比较
undefined -> o 比较
... 后面的忽略

根据给的 order 比较单词字母的顺序 如果 h -> l 比较 h 小 那么则是正确的 则继续下一个比较 如果相等 那么继续下一个比较 如果 l -> e 比较 l 比 e 大，那么直接终止 返回 false 当然 还有 undefined -> o 这种异常情况 这种默认是前者比后者小

题解

```js
function isAlienSorted(words: string[], order: string): boolean {
  let data = new Map();
  for (let i = 0; i < order?.length; i++) {
    // 把order顺序存储下来
    data.set(order[i], i);
  }
  // 异常情况也存储
  data.set(undefined, -1);
  for (let i = 0; i < words?.length - 1; i++) {
    for (let j = 0; j < Math.max(words[i]?.length, words[i + 1]?.length); j++) {
      if (words[i][j] === words[i + 1][j]) continue; // 如果相等则终止 跳出 继续下一个
      if (data.get(words[i][j]) > data.get(words[i + 1][j])) return false;
      // 如果 data.get(words[i][j])<data.get(words[i+1][j]) 也终止跳出 继续下一个
      break;
    }
  }
  return true;
}
```

时间：2022-05-17

## 最少移动次数使数组元素相等 II

给你一个长度为 n 的整数数组 nums ，返回使所有数组元素相等需要的最少移动数。

在一步操作中，你可以使数组中的一个元素加 1 或者减 1 。

示例 1：

输入：nums = [1,2,3]
输出：2
解释：
只需要两步操作（每步操作指南使一个元素加 1 或减 1）：
[1,2,3] => [2,2,3] => [2,2,2]

分析：这题我的解法是通过中位数获取最优解，那为什么中位数是最优解呢，那么我们来分析一下

假设 我们给一个有序的数组 [a,b] b 比 a 大

第一种：
设定目标值 x 是在 a b 之间 ，
那么移动的次数 = x-a + b - x 得出 b-a

第二种：
设定目标值 x 是 大于 b 的
那么移动的次数 `= x-b + x - a =(x+b-b-b)+(x-a) = (b-a)+2*(x-b)` 这个步数一定是大于 b-a 的

第三种：
设定目标 x 是小于 a 的
那么移动的次数` = (b - x) + (a - x) = (b - a + a - x) + (a - x) = b - a + 2 * (a - x)`这个步数也是是大于 b-a 的

所以取中位数是步数最少的最优解

那么我们就可以开始排序数组 取中位数 遍历循环出 具体看下面解法

```js
function minMoves2(nums: number[]): number {
  nums.sort((a, b) => a - b);
  let n = nums?.length;
  let mind = nums[Math.floor(n / 2)];
  let res = 0;
  for (let i = 0; i < n; i++) {
    res += Math.abs(nums[i] - mind);
  }
  return res;
}
```

时间：2022-05-19

## 单词距离

有个内含单词的超大文本文件，给定任意两个不同的单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?

示例：

输入：words = ["I","am","a","student","from","a","university","in","a","city"], word1 = "a", word2 = "student"
输出：1

分析 ：最开始想的是双层循环变量 取比较多最小值 但是时间复杂度比较，后面看了官方题解 比较好，每次遍历记录对应单词的下标 然后取最小值
比较容易理解 看代码即可

```js
function findClosest(words: string[], word1: string, word2: string): number {
  let length = words?.length;
  let ans = length;
  let index1 = -1,
    index2 = -1;
  for (let i = 0; i < words?.length; i++) {
    let word = words[i];
    if (word === word1) {
      index1 = i;
    }
    if (word === word2) {
      index2 = i;
    }
    if (index1 >= 0 && index2 >= 0) {
      ans = Math.min(ans, Math.abs(index2 - index1));
    }
  }
  return ans;
}
```

时间：2022-05-27

## 删除最外层的括号

输入：s = "(()())(())"
输出："()()()"
解释：
输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。

解析：利用栈的进出 拼接字符串 需要注意的一点是 一定要首先判断 是否要出栈

举个例子 (()) 开始 第一个括号入栈 然后栈中有了数据 第二个括号入栈 拼接到字符串上，第三个出栈 再次拼接 第四个出栈 栈为空 不拼接 所以删除了最外层括号，简单题 也没啥好说的 能想到方法 基本都可以写出代码

```js
function removeOuterParentheses(s: string): string {
  let str = "";
  const stack = [];
  for (let i = 0; i < s.length; i++) {
    const c = s[i];
    if (c === ")") {
      stack.pop();
    }
    if (stack.length) {
      str = str + c;
    }
    if (c === "(") {
      stack.push("(");
    }
  }
  return str;
}
```

时间：2022-05-28
