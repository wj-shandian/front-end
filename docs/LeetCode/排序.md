## 基础排序

### 冒泡排序

什么是冒泡排序

冒泡排序的过程，就是从第一个元素开始，重复比较相邻的两个项，若第一项比第二项更大，则交换两者的位置；反之不动。
每一轮操作，都会将这一轮中最大的元素放置到数组的末尾。假如数组的长度是 n，那么当我们重复完 n 轮的时候，整个数组就有序了。

以 数组 [3,1,4,2] 为例

- 首先 3 和 1 进行比较 如果 3 比 1 大 那么交换位置

```js
[1, 3, 4, 2]
 ↑  ↑
```

- 将第二个元素 3 和 4 进行比较 3 没有 4 大 所以位置不用交换

```js
[1, 3, 4, 2]
    ↑  ↑
```

- 将第三个元素 4 和 2 比较 4 比 2 大 所以位置交换

```js
[1, 3, 2, 4]
       ↑  ↑
```

然后这一轮排序就结束 4 最大数就冒泡到了最后的位置

然后重复上面的操作比较 开始第二轮 这里就直接写上第二轮的结果

```js
[1, 2, 3, 4]
       ↑  ↑
```

这个时候我们发现 此时 数组已经是一个有序的数组了 但是此时循环是不会停止的 只不过因为都是有序的 所以不会发生交换

因为有四个元素 理论上会走四遍 这里就是一个可以优化的点 已经是有序的数组 我们就可以终止循环了

- 基本冒泡的的编码实现

```js
function bubbleSort(arr) {
  let n = arr.length;
  // 外层循环用于控制从头到尾的比较+交换到底有多少轮
  for (let i = 0; i < n; i++) {
    // 内层循环用于完成每一轮遍历过程中的重复比较+交换
    for (let j = 0; j < n - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // 若相邻元素前面的数比后面的大
        // 交换两者
        let temp = arr[j + 1];
        arr[j + 1] = arr[i];
        arr[i] = temp;
      }
    }
  }
  return arr;
}
```

上面我们说到 已经是有序的数组 如果没有循环完 那么这个时候还是会继续循环 我们可以优化一下 经历几次循环后 后面的数组 都是有序的了 所以我们可以避免 循环到 n 个元素

- 优化后的冒泡排序

```js
function bubbleSort(arr) {
  let n = arr.length;
  // 外层循环用于控制从头到尾的比较+交换到底有多少轮
  for (let i = 0; i < n; i++) {
    // 内层循环用于完成每一轮遍历过程中的重复比较+交换
    // 主要在于 j < n - 1 - i
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        // 若相邻元素前面的数比后面的大
        // 交换两者
        let temp = arr[j + 1];
        arr[j + 1] = arr[i];
        arr[i] = temp;
      }
    }
  }
  return arr;
}
```

- 再次优化后的冒泡排序

如果给的数组本身就是一个有序的数组 上面的写法时间复杂度过高 我们还可以再次 优化

```js
function bubbleSort(arr) {
  let n = arr.length;
  // 外层循环用于控制从头到尾的比较+交换到底有多少轮
  for (let i = 0; i < n; i++) {
    // 添加一个标志位
    let flag = false;
    // 内层循环用于完成每一轮遍历过程中的重复比较+交换
    // 主要在于 j < n - 1 - i
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        // 只要发生了一次交换，就修改标志位
        flag = true;
        // 若相邻元素前面的数比后面的大
        // 交换两者
        let temp = arr[j + 1];
        arr[j + 1] = arr[i];
        arr[i] = temp;
      }
    }
    if (!flag) return arr;
  }
  return arr;
}
```

标志位可以帮助我们在第一次冒泡的时候就定位到数组是否完全有序，进而节省掉不必要的判断逻辑，将最好情况下的时间复杂度定向优化为 O(n)。

### 插入排序

### 选择排序

## 进阶排序

### 归并排序

### 快速排序
