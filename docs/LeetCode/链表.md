## 删除排序链表中的重复元素 II（中等）

存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中   没有重复出现   的数字。

返回同样按升序排列的结果链表。

输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]

开始有想到 一次遍历然后判断相等的数删除掉（因为是排序的） 但是代码实现不知道怎么写，（还是要多练），于是看了官方题解，感觉还是比较容易理解，具体分析 写在代码注释中

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function (head) {
  if (!head) return head;
  let dy = new ListNode(0, head); //  创建一个新的表头元素，避免从表头开始就重复，产生错误
  let cu = dy;
  while (cu.next && cu.next.next) {
    // 如果下一个数和下下个数有值则继续循环，否则结束
    if (cu.next.val === cu.next.next.val) {
      // 判断下一个数和下下个数的值是否相等
      const x = cu.next.val;
      while (cu.next && cu.next.val === x) {
        cu.next = cu.next.next; // 这一步相当于删除操作，如果数值一直相同，那么链表的指向一直向下直到不同的数为止
      }
    } else {
      // 数值不同，正常指向下一个数值
      cu = cu.next;
    }
  }
  return dy.next;
};
```

次数（1）

## 反转链表（简单题）

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL

题目很好理解，反转链表，虽然时简单题目，但是链表还是不熟练，理解上花费了一些时间
解法实际上使用的双指针的解法（应该再双指针的列表下的）

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function (head) {
  let cur = head;
  let pre = null;
  while (cur) {
    let temp = cur.next;
    cur.next = pre;
    pre = cur;
    cur = temp;
  }
  return pre;
};
```

搭配动态图片理解可能更容易一点 图片来源 leetcode 评论区
![](img/03.gif)

次数（1）

## 相交链表

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

示例：

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

分析：给两个链表 找到第一个相交 的点就返回 没有就返回 null 比较好理解

```Ts
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {
     if(headA === null || headB === null) return null
     // 创建一个集合  然后遍历把第一个链表的值全部放入
     let data = new Set()
     while(headA !== null){
         data.add(headA)
         headA = headA.next
     }
     let temp = headB
     // 遍历第二个链表 在集合中查找 如果有相同的值 则立即返回
     while(temp !==null){
         if(data.has(temp)){
             return temp
         }
         temp = temp.next
     }
     return null
};
```
