## 树的基本概念

![](img/tree1.png)

树的几个概念

- 树的层次计算规则：根结点所在的那一层记为第一层 其子结点所在的第二层 以此类推
- 结点和树的高度计算规则：叶子结点高度记为 1，每向上一层 高度 +1 一直累加到目标结点，此时的值就是目标结点的高度，树中结点最大高度成为树的高度
- “度的概念”：一个结点开叉出去多少个子树，被记为结点的度 比如上面的图 根结点的度 是 3 因为有三个子结点
- 叶子结点：叶子结点就是度为 0 的结点，因为叶子结点 没有儿子

二叉树的概念

- 二叉树可以没有根结点 作为一颗空树
- 如果不是空树，那么必须有根结点 左子树 和 右子树

在 js 中 树使用对象来定义，一共有三块

- 数据域
- 左侧子结点的引用
- 右侧子结点的引用

树的构造函数

```js
function TreeNode(val) {
  this.val = val;
  this.left = this.right = null;
}
```

所以一颗树大体样式应该是这样的 见下图
![](img/tree2.png)

## 二叉树的遍历

二叉树的遍历有四种，分别是

- 先序遍历(递归遍历)
- 中序遍历(递归遍历)
- 后续遍历(递归遍历)
- 层次遍历(迭代遍历)

我们先来看一个最简单的树的遍历

![](img/tree3.png)

这样一颗树的遍历有三种

- 根结点 -> 左子树 -> 右子树 （先序）
- 左子树 -> 根结点 -> 右子树 （中序）
- 左子树 -> 右子树 -> 根结点 （后序）

先序中序后序 其实指的就是根结点的时机

看一下先序遍历函数的代码

```js
// 入参是树的根结点
function preOrder(root) {
  // 递归边界值判断
  if (!root) {
    return;
  }
  console.log(root.val, "当前节点的值");
  // 递归遍历左子树
  preOrder(root.left);

  // 递归遍历右子树
  preOrder(root.right);
}
```

图解先序遍历过程 帮助理解

![](img/tree5.jpg)

看一下中序遍历的代码

```js
// 所有遍历函数的入参都是树的根结点对象
function inOrder(root) {
  // 递归边界，root 为空
  if (!root) {
    return;
  }

  // 递归遍历左子树
  inOrder(root.left);
  // 输出当前遍历的结点值
  console.log("当前遍历的结点值是：", root.val);
  // 递归遍历右子树
  inOrder(root.right);
}
```

图解省略 可以自己根据先序的 自己分析

看一下后序遍历的代码

```js
    function postOrder(root) {
    // 递归边界，root 为空
    if(!root) {
        return
    }

    // 递归遍历左子树
    postOrder(root.left)
    // 递归遍历右子树
    postOrder(root.right)
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)
}
}
```

## 二叉树的中序遍历

给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。

输入：root = [1,null,2,3]
输出：[1,3,2]

递归是比较简单的一种方式，基本上学习过树的一些概念 都可以想到

```js
function inorderTraversal(root: TreeNode | null): number[] {
  let res = [];
  const dfs = (root) => {
    if (!root) return;
    dfs(root.left);
    res.push(root.val);
    dfs(root.right);
  };
  dfs(root);
  return res;
}
```

迭代：

维护一个栈，遇到左子树就放入栈中，直到左子树为空 然后出栈 放入数组

```js
function inorderTraversal(root: TreeNode | null): number[] {
  let res = [];
  let stack = [];
  while (stack.length || root) {
    while (root) {
      stack.push(root);
      root = root.left;
    }
    let node = stack.pop();
    res.push(node.val);
    root = node.right;
  }
  return res;
}
```

如果不理解 可以看官方的动图
[官方图解](https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/)
