![](TCP/tcp_disconnect.jpg)

## 四次挥手过程 和状态的变化

![](TCP/tcp_12.jpg)

- 客户端打算关闭连接 此时会发送一个 TCP 首部 FIN 标志位 被置为 1 的报文 也叫 FIN 报文，之后客户端进入 FIN_WAIT_1 状态
- 服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务器进入 CLOSE_WAIT 状态
- 客户端收到服务端的 ACK 应答报文后 之后进入 FIN_WAIT_2 状态
- 等待服务器处理完数据后， 服务器再次向客户端发送 FIN 报文 之后服务器进入 LAST_ACK 状态
- 客户端收到服务器的 FIN 报文后，会一个 ACK 的应答报文 之后进入 TIME_WAIT 状态
- 服务器接收 ACK 报文后 就进入了 CLOSED 状态，到这里服务器就已经完成了连接的关闭
- 客户端在等待 2MSL 时间后 自动进入 CLOSED 状态 到这里客户端也完成了 连接的关闭

只有主动关闭的时候 才会有 TIME_WAIT 状态

## 为什么需要四次挥手

关闭连接的时候 客户端向服务端发送一个 FIN 时 只是表示客户端不再发送数据了，但是还可以接受数据

服务端 收到客户端的 FIN 报文 先回一个 ACK 应答报文，而服务端可能还有数据处理和发送， 等待服务器不再发送数据，再发送 FIN 报文给客户端同意关闭连接

这里的 服务端发送给客户端的 ACK 和 FIN 一般是分开发送的，所以比三次握手多了一次 需要四次

## 为什么 TIME_WAIT 等待的时间是 2MSL

MSL 意思是报文的最大生存时间，如果超过这个时间 那么报文就会被丢弃

TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是: 网络中可能存在来自发送方的数据包，当这些发送方的数据包 被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。

2MSL 的时间是从客户端接受到 FIN 后发送 ACK 开始计时的，如果 在 TIME_WAIT 时间内 因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重新发送到 FIN 报文 那么这个时间会重新计时

2MSL 在 Linux 中一般是 60s

## 为什么需要 TIME_WAIT

主动发起关闭连接到一方才会有 TIME_WAIT

需要这个状态的原用有两个

- 防止旧的数据包被接受

![](TCP/tcp_13.jpg)

看上面的图 如果 TIME_WAIT 时间很短或者 不存在的话 服务端在网络关闭连接前发送了一个报文 被网络延迟了

这个时候 有一个相同的 TCP 端口 连接被复用，这个时候 被延迟的报文发送到了客户端 那么客户端是有可能正常的接受这个过期的报文 这个时候会产生数据错乱

所以 TCP 设计了 TIME_WAIT 经过 2MSL 时间 双方产生的数据包 都会在这个时间内消失 再出现的数据包一定是新建立的连接产生的

- 保证 被动关闭连接的一方能被正确的关闭 即保证最后的 ACK 能让被动关闭放接受，从而帮助其关闭

![](TCP/tcp_14.jpg)

看上图

如果没有 TIME_WAIT 或者很短，那么客户端在最后发给服务端的报文 在传输过程丢失了 那么服务端会一直处于 LAST_ACK 状态

当客户端发起建立连接的 SYN 请求报文后，服务端会发送 RST 报文给客户端，连接建立的过程就会被终 止。

---

如果 TIME_WAIT 时间足够长

- 服务端正常能接受 最后一个报文 然后关闭连接
- 服务端没有收到 最后一个 ACK 报文 服务端则会重新发送 FIN 关闭连接报文 并等待新的 ACK 报文

这样就可以保证对方可以正确的关闭

## TIME_WAIT 过多的危害

如果服务器出现 TIME_WAIT 状态 则说明 是服务器主动发起的断开连接

TIME_WAIT 出现的过多 主要的危害有

- 内存资源的占用过多
- 对端口的占用过多 如果占满了所有的端口 那么将无法建立新的连接

## 如果优化 TIME_WAIT

- 打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 、
  如果 Linux 内核中 打开了上面两个参数 则可以复用处于 TIME_WAIT 的 socket 为新的连接所用
  tcp_tw_reuse 功能只能用在客户端 因为开启了该功能 在调用 connect()函数时 内核会随机找一个 TIME_WAIT 状态超过 1 秒的连接 给新的连接复用
  使用这个 net.ipv4.tcp_tw_reuse 还需要打开 net.ipv4.tcp_timestamps 这个参数
  这个时间戳的字段 是在 TCP 头部的选项字段里 用于记录 TCP 发送方当前时间戳和从对方接受到最新的时间戳
  由于引入了时间戳 前面说的 2MSL 问题就不会有了

- net.ipv4.tcp_max_tw_buckets
  这个值默认为 18000，当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接
  状态重置。

- 程序中使用 SO_LINGER ，应用强制使用 RST 关闭
  我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。

  ```
  struct linger so_linger;
  so_linger.l_onoff = 1;
  so_linger.l_linger = 0;
  setsockopt(s, SOL_SOCKET, SO_LINGER, &so_linger,sizeof(so_linger));
  ```

  如果 l_onoff 为非 0， 且 值为 0，那么调用 close 后，会立该发送一个 RST 标志给对端，该 TCP 连接 将跳过四次挥手，也就跳过了 状态，直接关闭。

## 如果建立了连接 客户端出现故障了怎么办

TCP 有一个机制是 保活机制

定义一个时间段 在这个时间段内 如果没有任何连续相关的活动，TCP 保活机制就会开始作用，每隔一段时间 发送一个探测报文

这个探测报文数据很少，如果连续几个探测报文都有得到响应 则认为 当前的 TCP 连接 已经死亡，系统内核将错误信息通知给上层应用程序

在 Linux 内核中可以设置保活时间 保活的探测次数 保活的探测的时间间隔

```js
net.ipv4.tcp_keepalive_time = 7200; // 默认值 表示保活时间是 7200秒  也就是2小时没有任何连接 则会启动保活机制
net.ipv4.tcp_keepalive_intvl = 75; //默认值 每次间隔 75 探测一次
net.ipv4.tcp_keepalive_probes = 9; // 默认值 表示9次探测都没有响应 则认为TCP已经死亡 断开连接
```

如果开启了 TCP 保活，需要考虑以下几种情况:

1. 对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被 重置，等待下一个 TCP 保活时间的到来。
2. 对端程序崩溃并 􏰀 启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的 有效信息，会产生一个 RST 报文，这样很快就会发现 TCP 连接已经被 􏰀 置。
3. 是对端程序崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大 海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。
