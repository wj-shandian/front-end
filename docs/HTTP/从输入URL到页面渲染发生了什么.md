## 总览过程

- 输入地址，浏览器查找 ip 地址（dns 域名解析）
- 浏览器发送 http 请求 （tcp 建立连接 三次握手）
- 服务器永久重定向响应
- 服务器处理请求，返回 HTTP 响应
- 浏览器渲染 HTML

## 过程分析

- 输入地址，浏览器查找 ip 地址（dns 域名解析）  
   当我们在浏览器输入地址，然后浏览器会根据地址进行域名解析 (url 解析)

  - 协议
  - 登录信息验证
  - 域名:服务器地址
  - 端口号（http 默认 80 https 默认 443 FTP 默认 21）
  - 请求资源文件路径
  - 查询字符串等

  其次 DNS 会进行缓存查找  
   缓存位置分为 ： 内存缓存（memory Cache） 硬盘缓存（Disk Cache）

  - 打开网页：查找 Disk Cache 是否有匹配，有就直接使用，没有就发送网络请求
  - 普通刷新（F5）:因为 tab 没有关闭 因此 memory cache 是可用的，会优先被使用，其次才是 Disk Cache
  - 强制刷新（Ctrl+F5）:浏览器不适用缓存 ，因此发送的请求头部均带有 Cache-control: no-cache，服务器直接返回 200 和最新内容

  - 浏览器缓存
  - 系统缓存
  - 路由器缓存
  - ISP DNS 缓存

  其次如果没有命中本地 host 缓存，那么 DNS 会发起一个请求到本地服务器 进行 DNS 查询，
  主要分为两种

  - 递归查询
    ![](img/duigua.jpg)
    递归查询主要是缓存查询，如果没有找到缓存那么就会进行迭代查询
  - 迭代查询
    ![](img/diedai.jpg)
    迭代查询主要就是客户端向本地服务器发起请求，本地服务器挨个取各个服务器找寻资源的一个过程，最后拿个结果返回给就客户端

  每一次 DNS 的解析时间预计在 20 到 120 毫秒之间，那么 DNS 解析如何优化呢？ - 减少 DNS 请求次数 - DNS 预获取

  ```js
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="dns-prefetch" href="//static.360buyimg.com"/>
  <link rel="dns-prefetch" href="//misc.360buyimg.com"/>
  <link rel="dns-prefetch" href="//img10.360buyimg.com"/>
  <link rel="dns-prefetch" href="//d.3.cn"/>
  <link rel="dns-prefetch" href="//d.jd.com"/>

  // 控制标签  rel="dns-prefetch"
  ```

  DNS 负载均衡是什么意思？  
   当有很多用户访问一个网站，并且网站请求资源都在同一个服务器上，那么这台服务器可以随时会崩掉，这个时候我们就需要用到 DNS 负载均衡

  原理：在 DNS 服务器上同为一个主机名称配置多个 IP 地址，在 DNS 查询时，DNS 对每个查询都以主机记录的 Ip 地址返回不同的解析结果，然后客户端可以访问不同服务器资源

- 浏览器发送 http 请求
  拿到域名之后，这个时候浏览器会向服务器发起请求
  首先是建立 TCP 连接（这个时候需要三次握手建立连接）

  - 三次握手  
    第一次：客户端发起请求，携带 SYN=1 随机产生一个 seq=j 的数据包到服务器，客户端进入等待状态。

    第二次：服务端接收到数据包 由标志位 SYN=1 可以知道是建立链接的请求，服务端将标志位 SYN 和 ACK 的值都改为 1，ack 等于 j+1，并随即产生一个 seq=k 的值，并将数据包发给客户端

    第三次：客户端收到请求，检查 ack 是否等于 j+1 ACK 是否为 1，如果都正确，就将 ACK=1 ack=k+1 数据包传给服务端，服务端检查 ack 是否是 k+1,正确则建立连接

    ![](img/san.jpg)

    为什么需要三次握手：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误(核心思想保证数据可靠传输，和数据传输效率)

- 服务器永久重定向响应

  301：表示旧地址 A 的资源已经被永久地移除了（这个资源不可访问了）  
  302：表示旧地址 A 的资源还在（仍然可以访问），这个重定向只是临时地从旧地址 A 跳转到地址 B

  尽量减少重定向，因为每次重定向内容都会重新发送请求，页面渲染时间加长，增加用户等待时间

- 服务器处理请求，返回 HTTP 响应  
  发送 http 请求会经过缓存，缓存的具体分析可以查看上一节内容。

  服务器响应，获取到资源  
   响应报文由响应行（request line）、响应头部（header）、响应主体三个部分组成

  - 状态码
    1xx：指示信息--表示请求已接收，继续处理。  
     2xx：成功--表示请求已被成功接收、理解、接受。  
     3xx：重定向--要完成请求必须进行更进一步的操作。  
     4xx：客户端错误--请求有语法错误或请求无法实现。  
     5xx：服务器端错误--服务器未能实现合法的请求。

- 浏览器渲染页面

  - 1、构建 html 树 （dom）
  - 2、构建 css 树（cssom）
  - 3、将两棵树合并成一棵树 （render tree）
  - 4、Layout 布局（文档流、盒模型、计算大小、位置）【主要动 html 或有关的 css】
  - 5、paint 绘制（绘制颜色、阴影等）【主要动 css】
  - 6、compsite 合并 根据层叠关系展示画面

- 断开连接

tcp 断开连接 ，四次挥手

- TCP 四次挥手  
  第一次挥手: 客户端发起关闭的请求，发送数据 FIN = m  
  第二次挥手：服务端获取数据，发送 ack = m+1 服务端进入等待状态  
  第三次挥手：服务端发送一个 FIN = k 用来关闭服务端和客户端的数据传送  
  第四次挥手：客户端收到数据，并发一个请求给服务端 确认收到 序号为 k+1

  为什么需要四次挥手：因为 tcp 是全双共通信，客户端和服务端都可以接受和发送数据，因此完全断开，需要双发都确认不再发送数据

![avatar](img/si.jpg);

## 性能优化点

- 利用缓存
  - 对于静态资源实现强缓存和协商缓存
  - 对于不经常更新的接口数据采用本地存储，做数据缓存
- DNS 优化
  - 分服务器部署 增加 HTTP 并发性
  - DNS 预解析
- TCP 三次握手和四次挥手
  - Connection:keep-alive 保持长连接
- 数据传输
  - 减少数据传输大小
    - 内容压缩
    - 服务器端开启 GZIP 压缩
    - 大量数据采用分批次请求（如分页）
  - 减少 HTTP 请求
    - 资源文件合并
    - 字体图标
    - 雪碧图
    - 图片 base64
- 采用 HTTP2.0

如何增加用户体验，减少等待时间的优化

- 骨架屏
- 图片懒加载
- 增加 loading

## HTTP1.0 和 HTTP2.0 和 HTTP3.0 的区别

### 1.0 和 1.1 的主要区别

- 缓存处理：HTTP1.0 中主要使用 Last-Modified，Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略：ETag，Cache-Control
- 带宽优化以及网络链接的使用：HTTP1.1 支持 断点续传
- 长连接：1.1 中默认开启了 Connection： keep-alive
- 错误通知管理：1.1 增加了一些错误通知码

### 2.0 和 1.x 主要的区别

- 多路复用
  - HTTP/1.0 每次请求响应，建立一个 TCP 连接，用完关闭
  - HTTP/1.1 「长连接」 若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；
  - HTTP/2.0 「多路复用」多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行；
- 服务端推送：例如我的网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了
- header 压缩：HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小
- 新的二进制格式：HTTP1.x 的解析是基于文本，基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合，基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮
