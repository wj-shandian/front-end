## 联合类型

联合类型（Union Types）表示取值可以为多种类型中的一种。

```js
// 最简单demo
let myName: number | string;
myName = 10;
myName = "10";
// 这样设置ts是不会报错的

myName = true; // 这样会报错 不能将类型“boolean”分配给类型“string | number”。ts(2322)
```

当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：

```js
// 类型“string | number”上不存在属性“length”。
//  类型“number”上不存在属性“length”
// 因为length 不是string和公有的属性
function getLength(something: string | number): number {
  return something.length;
}

// 这样写就是可以的，因为toString 是string和number的共有属性
function getLength(something: string | number): string {
  return something.toString();
}
```

## 接口类型

```js
// 简单的demo

interface Person {
  name: string;
  age: number;
}

let wj: Person = {
  name: "wj",
  age: 18,
};

// 定义了接口，那么里面的属性不能多也不能少，并且类型也不允许错误

// 可选属性 ?
interface Person {
  name: string;
  age?: number;
}

let wj: Person = {
  name: "wj",
};
// 加了可选属性，那么这个属性可以有也可以没有

// 任意属性
interface Person {
  name: string;
  age?: number;
  [propName: string]: any;
}

let wj: Person = {
  name: "wj",
  age: 18,
  sex: "男",
};
// 这样设置会报错，一旦设置了可选属性和任意属性，那么可选属性的类型必须是任意类型的子集
// 我们可以使用联合类型解决这个问题

interface Person {
  name: string;
  age?: number;
  [propName: string]: string | number;
}

let wj: Person = {
  name: "wj",
  age: 18,
  sex: "男",
};

// 只读属性
interface Person {
  readonly id:number
  name: string;
  age?: number;
  [propName: string]: any;
}

let wj: Person = {
  id:1,
  name: "wj",
  age: 18,
  sex: "男",
};

wj.id = 2 // 报错，因为id是只读的不能修改


interface message {
  name: string;
  age: () => number; // 声明一个函数类型
}
function getMessage(message: message): void {
  console.log(message);
}
const a = {
  name: "name",
  age: () => 2012,
};
getMessage(a);
```

## 函数类型

```js
// 参数不能多也不能少
function sum(x: number, y: number): number {
  return x + y;
}
sum(10, 20); // 正确
sum(10, 20, 30); // 报错 应有 2 个参数，但获得 3 个。ts(2554)

// 可选参数，同样可以设置可选参数可以输入多个或者少于要求的参数

function sum(x: number, y?: number): number {
  if (y) {
    return x + y;
  }
  return x;
}
sum(10);

// 需要注意的点是，可选参数必须放在比需参数之前

// 函数类型推断

let sum: (x: number, y: number) => number = function (
  x: number,
  y: number
): number {
  return x + y;
};

// 这里的箭头函数不是 es6箭头函数，而是类型推断的箭头函数

// 默认参数

function sum(x: number, y: number = 10): number {
  return x + y;
}
sum(10);
// 当我们参数有默认值的时候，我们也可以值输入一个值，而不是必须的两个

// 剩余参数
function push(array: any[], ...items: any[]) {
  items.forEach(function (item) {
    array.push(item);
  });
}

let a = [];
push(a, 1, 2, 3);
```

## 内置对象

BOM 和 DOM

```js
let body: HTMLElement = document.body;
let allDiv: NodeList = document.querySelectorAll("div");
document.addEventListener("click", function (e: MouseEvent) {
  // Do something
});
```

ES 内置对象

```js
let b: Boolean = new Boolean(1);
let e: Error = new Error("Error occurred");
let d: Date = new Date();
let r: RegExp = /[a-z]/;
```

## 类型别名

```js
// 类型别名
type language = {
  name: string,
  age: () => number,
};
/*
 看上去像是定义一个变量一样 只不过关键词是type
 类型别名可以 用于联合类型和交叉类型 
*/
type a = string;
type b = number;
type c = a | b;
function d(n: c): void {
  console.log(n);
}
// 类型别名和接口看起来很类似，他们大部分使用的场景都可以相互替代，但是不完全等价
// 比如重复定义的接口类型 他们的属性会叠加  而类型别名重复定义会报错
{
  interface Language {
    id: number;
  }

  interface Language {
    name: string;
  }
  let lang: Language = {
    id: 1, // ok
    name: "name", // ok
  };
}
```

## 字符串字面量类型

```js
// 同样也是用type 关键字定义 用来约束 只能去字符串中的某一个

type Name = "qq" | "ww" | "zz";
function a(n: Name): void {
  console.log(n);
}
a("qq"); //只能传定义的某一个 否则会报错
```

## 泛型

## 交叉类型

联合类型使用的 |

没错交叉类型使用是 &

```js
type a = string & number;
// 这样写是没有意义的 因为没有类型能满足条件

// 一般使用交叉类型 都用于合并接口类型
type IntersectionType = { id: number, name: string } & { age: number };
const mixed: IntersectionType = {
  id: 1,
  name: "name",
  age: 18,
};
// 交叉类型和联合类型是可以组合使用的
```
