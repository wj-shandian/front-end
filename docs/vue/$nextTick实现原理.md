## js 运行机制

说到 nextTick 就会牵扯到 js 运行机制，以及宏任务和微任务（想了解宏任务和微任务可以查看之前的文章 ，事件循环）

首先 js 是单线程的，他的运行机制是基于事件循环

- 所有的同步任务都是在主线程执行的，
- 主线程之外我们还有 一个任务队列， 用来存异步任务的结果
- 一旦主进程的任务清空，那么任务队列中的任务就会被推入主进程当中执行
- 依次循环，这就是事件循环

## 看看 nextTick

源码位置：src/core/util/next-tick.js

其作用：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。  
比如说：比如从服务端接口去获取数据的时候，数据做了修改，如果我们的某些方法去依赖了数据修改后的 DOM 变化，我们就必须在 nextTick 后执行

主要原理是利用宏任务微任务把要执行的方法压入任务队列，等待主进程执行完毕再执行任务队列

next-tick.js 申明了 microTimerFunc 和 macroTimerFunc 2 个变量，它们分别对应的是 micro task 的函数和 macro task 的函数。对于 macro task 的实现，优先检测是否支持原生 setImmediate，这是一个高版本 IE 和 Edge 才支持的特性，不支持的话再去检测是否支持原生的 MessageChannel，如果也不支持的话就会降级为 setTimeout 0；而对于 micro task 的实现，则检测浏览器是否原生支持 Promise，不支持的话直接指向 macro task 的实现
