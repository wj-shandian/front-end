## 概述

垃圾回收的基本思路：确定哪个变量不会再使用，然后就释放占用的内存，这个过程是周期性的，每隔一段时间就会自动运行

## 标记清理

最常用的垃圾回收策略：标记清理。

这个算法把对象是否不再需要 简化定义为 对象是否可以获得

简单理解：垃圾回收运行时，上下文中的所有变量都会被标记，那么无法被标记的就会被回收

标记清理的缺点：

- 内存碎片化，因为内存是连续的，容易出现很多空闲的内存块，还可能会出现分配内存过大的对象找不到合适的块
- 分配速度慢 因为清理之后 内存空间空间不是连续的 所以分配内存是需要遍历，找到合适的内存

所以最主要的问题是：清除之后没改变剩余对象位置而导致内存不连续

所以标记整理就解决了这个问题，标记整理会在清除之后，将还存在的对象向内存的一端移动，最后清理掉边界的内存

## 引用计数

不常用的引用计数

此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它” 如果没有引用指向该对象，那么对象将被垃圾回收

缺陷：循环引用会导致无法回收

## V8 引擎的垃圾回收

<!-- https://juejin.cn/post/6844904016325902344#heading-1 -->

谷歌 => 查找引用

浏览器的渲染引擎会再空闲的时候（定期时间）依次遍历所有的内存 栈和堆
栈：当前上下文中是否有内容（一般是指堆内存）被上下文以外的事物所占用，如果被占用，则无法被释放（闭包）
如果没有被占用则释放掉，EC（G）全局上下文只有页面加载才被创建，只有关闭页面的时候才被释放

堆：当前堆内存如果被占用（指针关联的地址） 则不能被释放，如果没有任何事物被占用这个堆，则浏览器会自动释放掉

IE => 引用计数
每一个内存中都有一个数字 N 记录被占用的次数，如果当前内存被占用一次，则内存中的 N 会累加一次，反之取消占用，累加值会减少，如果 N 为 0 那么直接释放内存

如果手动释放内存，把变量置为 null 接口 ，null 是不占用内存的
