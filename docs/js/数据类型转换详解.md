## 数字

把其他类型转化成 Number 的规则

1.特定需要转化成 Number

- Number()
- parseInt/parseFloat

  2.隐式转化（浏览器内部默认转成 Number()计算）

- isNaN() 会先转成数字再计算
- 数学运算符（+ 在出现字符串的时候是拼接不是数学运算）
- 在==比较的时候有些需要转化成数字比较

```js
console.log("10px"); // NaN 只要出现非有效字符串 那么就是NaN
console.log(undefined); // NaN
console.log(null); // 0
console.log(Symbol(10)); // 报错
```

```js
// parseInt 机制：从左侧第一个字符开始查找，查找有效数字字符（遇到非有效数字将停止查找，把找到的有效数字字符转化成数字，没有就是NaN,parseFloat只多识别一个小数点）
//
```

## 字符串

把其他类型转化成 String 的规则

1. 能使用的方法

   - toString()
   - String()

2. 隐式转化（一般都是调用 toString()转化）

- 加号运算 如果一边是字符串，那么就是字符串拼接
- 把对象转成数字，需要先用 toString()转成字符串再转成数字
- 基于 alert/confirm/prompt 这些方式输出内容，都是先把内容转化成字符串，再输出

其他类型转化成字符串都很简单，只有{}普通对象是调取 toString(),而这个 toString 是调取 Object.prototype.toString()，这个不是用来转化成字符串，而是检测数据类型，返回结果"[Object Object]"

## 布尔值

1.基于一下方式可以把其他数据类型转化成布尔值

- !转化成布尔值后取反
- !!
- Boolean()

  2.隐式转化

- 在循环或者条件判断中，条件处理的结果就式布尔值

规则：只有 0 null NaN undefined 空字符串 会变成布尔值 false 其余全部式 true

## ==

在==比较的过程中，数据转换规则

类型一致

- {} == {} false ：对象比较的式堆内存地址
- [] == [] false
- NaN == NaN false

类型不一致

null=undefined 但是 === 就不相同因为类型不一致

字符串 == 对象 要把对象转成字符串

其余的 == 如果两边数据类型不一致，那么都要抓化成数字再比较

## 面试题

```js
console.log([] == false); // true
// 对象 == 布尔  都是转化成数字（隐式转化）
// 对象转数字：先toString()转化成字符串，（应该是先基于valueOf获取原始值，没有原始值再去toString）然后再转成数字
// 执行过程：[] 没有valueOf没有基本类型的值，所以直接toString()
// [].toString() 等于 ''
// ""转成数字  Number('') // 0
// false 转成数字 是0 所以两者相等

console.log(![] == false); // true
// ![] 把数组转化成布尔值然后取反  false
// false == false
```

```js
let res = 10 + false + undefined + [] + "Tencent" + null + true + {};
// 10+false = 10 false 会转化成0
// 10+undefined  NaN
// NaN + []  字符串"NaN"
// 后面都是字符串拼接了
// "NaNTencentnulltrue[Object Object]"
```

```js
let arr = [10.18, 0, 10, 25, 23];
arr = arr.map(parseInt);
console.log(arr);
```
