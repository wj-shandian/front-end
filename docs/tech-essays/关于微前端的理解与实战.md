## 什么是微前端

> 微前端的概念：构建一个现代 Web 应用所需要的技术/策略/方法，具备多个团队独立开发、部署的特性

微前端的优势

- 独立测试部署，各个模块相互独立，互不影响
- 扩展性高
- 技术兼容更好，各个模块可以使用不同的技术

微前端的缺点

- 子应用之间共享资源能力较差
- 需要对旧的代码改造升级才可以使用

目前主流的微前端解决方案

- iframe (最大的问题是 刷新页面 路由会丢失 本质刷新的主应用 而不是路由应用 所以被放弃了)
- `single-spa`和`qiankun`(是基于`single-spa`)封装的 这是一种基座模式（通过搭建基座配置中心来管理子应用）
- ESM 是 ES module 的缩写
- EMP 这是一种去中心模式（脱离基座模式 每个应用之间可以彼此分享资源）
- web Components

## qiankun 和 single-spa 实战

### single-spa

首先我们创建子应用，子应用我用的是 vue-cli,只需要简单的配置即可 路由和 babel

- single-child1

安装`npm i single-spa-vue`

修改 main.js 文件

```js
import Vue from "vue";
import App from "./App.vue";
import router from "./router";
import singleSpaVue from "single-spa-vue";

Vue.config.productionTip = false;

// new Vue({
//   router,
//   render: (h) => h(App),
// }).$mount("#app");
const appOptions = {
  el: "#vue", // 需要挂载的父应用的节点
  render(h) {
    return h(App);
  },
  router,
};

// 当父应用 调用我的时候，控制子应用路由跳转的资源引用路径
if (window.singleSpaNavigate) {
  // eslint-disable-next-line no-undef
  __webpack_public_path__ = "http://localhost:1000/";
}
// 支持应用独立运行、部署，不依赖于基座应用
if (!window.singleSpaNavigate) {
  delete appOptions.el;
  new Vue(appOptions).$mount("#app");
}

const vueLifecycles = singleSpaVue({
  Vue,
  appOptions,
});

// 导出生命周期
export const bootstrap = vueLifecycles.bootstrap;
export const mount = vueLifecycles.mount;
export const unmount = vueLifecycles.unmount;
```

配置 `vue.config.js` 把项目打包成 umd 格式

```js
module.exports = {
  configureWebpack: {
    devServer: {
      port: 1000,
    },
    output: {
      library: "app1",
      libraryTarget: "umd",
    },
  },
};
```

修改路由的 base

```js
const router = new VueRouter({
  mode: "history",
  // 这个名字需要和 打包的名字  以及 主应用引用的名称一样
  base: "/app1",
  routes,
});
```

- single-parent

然后创建基座应用 ，同样我们用 vue-cli 来创建一个简单的应用

然后安装 single-spa

修改 main.js

```js
import Vue from "vue";
import App from "./App.vue";
import router from "./router";
import { registerApplication, start } from "single-spa";

Vue.config.productionTip = false;

// 远程加载子应用
function createScript(url) {
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = url;
    script.onload = resolve;
    script.onerror = reject;
    const firstScript = document.getElementsByTagName("script")[0];
    firstScript.parentNode.insertBefore(script, firstScript);
  });
}

// 记载函数，返回一个 promise
function loadApp(url, globalVar) {
  // 支持远程加载子应用
  return async () => {
    await createScript(url + "/js/chunk-vendors.js");
    await createScript(url + "/js/app.js");
    // 这里的return很重要，需要从这个全局对象中拿到子应用暴露出来的生命周期函数
    return window[globalVar];
  };
}

const app = [
  {
    // 子应用名称
    name: "app1",
    // 子应用加载函数，是一个promise
    app: loadApp("http://localhost:1000", "app1"),
    // 当路由满足条件时（返回true），激活（挂载）子应用
    activeWhen: (location) => location.pathname.startsWith("/app1"),
    // 传递给子应用的对象
    customProps: {},
  },
  {
    // 子应用名称
    name: "app2",
    // 子应用加载函数，是一个promise
    app: loadApp("http://localhost:2000", "app2"),
    // 当路由满足条件时（返回true），激活（挂载）子应用
    activeWhen: (location) => location.pathname.startsWith("/app2"),
    // 传递给子应用的对象
    customProps: {},
  },
];
// 注册子应用
for (let i = app.length - 1; i >= 0; i--) {
  registerApplication(app[i]);
}
new Vue({
  router,
  mounted() {
    // 启动
    start();
  },
  render: (h) => h(App),
}).$mount("#app");
```

修改 app.vue 添加一个挂载的节点

```js
<template>
  <div id="app">
    <div id="nav">
      <router-link to="/app1">Home</router-link>|
      <router-link to="/app2">about</router-link>
    </div>
    <div id="vue">
      <router-view />
    </div>
  </div>
</template>
```

然后运行即可

### qiankun

qiankun 是基于 single-spa 的封装 ，qiankun 也是现在主流的微应用方案，

- qiankun-child

修改 main.js

```js
import Vue from "vue";
import App from "./App.vue";
import VueRouter from "vue-router";
import routes from "./router";
import "./public-path";
Vue.config.productionTip = false;
let router = null;
let instance = null;
// 渲染函数
function render(props = {}) {
  const { container } = props;
  router = new VueRouter({
    base: window.__POWERED_BY_QIANKUN__ ? "/app1" : "/",
    mode: "history",
    routes: routes.options.routes,
  });

  instance = new Vue({
    router,
    render: (h) => h(App),
  }).$mount(container ? container.querySelector("#app") : "#app"); // 挂载节点
}

// 独立运行时
if (!window.__POWERED_BY_QIANKUN__) {
  render();
}

// 导出的生命周期
export async function bootstrap() {
  console.log("[vue] vue app bootstraped");
}
export async function mount(props) {
  console.log("[vue] props from main framework", props);
  render(props);
}
export async function unmount() {
  instance.$destroy();
  instance.$el.innerHTML = "";
  instance = null;
  router = null;
}
```

添加一个 public-path.js 文件

```js
if (window.__POWERED_BY_QIANKUN__) {
  // 这里是支持修改的 原理和single-spa是一样的
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
}
```

添加 vue.config.js

```js
const { name } = require("./package");
module.exports = {
  publicPath: "/app1",
  devServer: {
    headers: {
      "Access-Control-Allow-Origin": "*",
    },
    port: 1000,
  },
  configureWebpack: {
    output: {
      library: `app1`,
      libraryTarget: "umd", // 把微应用打包成 umd 库格式
      jsonpFunction: `webpackJsonp_${name}`,
    },
  },
};
```

- qiankun-parent

安装 qiankun npm i qiankun -S

修改 main.js

```js
import Vue from "vue";
import App from "./App.vue";
import router from "./router";
import { registerMicroApps, start } from "qiankun";
Vue.config.productionTip = false;

registerMicroApps([
  {
    name: "app1", // app name registered
    entry: "http://localhost:1000/app1",
    container: "#vue",
    activeRule: "/app1",
  },
  {
    name: "app2",
    entry: "http://localhost:2000/app2",
    container: "#vue",
    activeRule: "/app2",
  },
]);

new Vue({
  router,
  mounted() {
    start();
  },
  render: (h) => h(App),
}).$mount("#app");
```

APP.vue 中要添加一个挂载的节点

```js
<template>
  <div id="app">
    <router-view />
    <div id="vue"></div>
  </div>
</template>
```

想要熟悉 ，可以自己实战一下，然后参照官方文档，相信会有一定的理解，之后再学习原理

## single-spa 和 qiankun 的原理
