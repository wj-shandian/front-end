## 什么是微前端

> 微前端的概念：构建一个现代 Web 应用所需要的技术/策略/方法，具备多个团队独立开发、部署的特性

微前端的优势

- 独立测试部署，各个模块相互独立，互不影响
- 扩展性高
- 技术兼容更好，各个模块可以使用不同的技术

微前端的缺点

- 子应用之间共享资源能力较差
- 需要对旧的代码改造升级才可以使用

目前主流的微前端解决方案

- iframe (最大的问题是 刷新页面 路由会丢失 本质刷新的主应用 而不是路由应用 所以被放弃了)
- `single-spa`和`qiankun`(是基于`single-spa`)封装的 这是一种基座模式（通过搭建基座配置中心来管理子应用）
- ESM 是 ES module 的缩写
- EMP 这是一种去中心模式（脱离基座模式 每个应用之间可以彼此分享资源）
- web Components

## qiankun 和 single-spa 实战

### single-spa

首先我们创建子应用，子应用我用的是 vue-cli,只需要简单的配置即可 路由和 babel

- single-child1

安装`npm i single-spa-vue`

修改 main.js 文件

```js
import Vue from "vue";
import App from "./App.vue";
import router from "./router";
import singleSpaVue from "single-spa-vue";

Vue.config.productionTip = false;

// new Vue({
//   router,
//   render: (h) => h(App),
// }).$mount("#app");
const appOptions = {
  el: "#vue", // 需要挂载的父应用的节点
  render(h) {
    return h(App);
  },
  router,
};

// 当父应用 调用我的时候，控制子应用路由跳转的资源引用路径
if (window.singleSpaNavigate) {
  // eslint-disable-next-line no-undef
  __webpack_public_path__ = "http://localhost:1000/";
}
// 支持应用独立运行、部署，不依赖于基座应用
if (!window.singleSpaNavigate) {
  delete appOptions.el;
  new Vue(appOptions).$mount("#app");
}

const vueLifecycles = singleSpaVue({
  Vue,
  appOptions,
});

// 导出生命周期
export const bootstrap = vueLifecycles.bootstrap;
export const mount = vueLifecycles.mount;
export const unmount = vueLifecycles.unmount;
```

配置 `vue.config.js` 把项目打包成 umd 格式

```js
module.exports = {
  configureWebpack: {
    devServer: {
      port: 1000,
    },
    output: {
      library: "app1",
      libraryTarget: "umd",
    },
  },
};
```
